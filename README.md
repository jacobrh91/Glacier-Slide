# Glacier Slide

Welcome to Glacier Slide, a simple terminal-based puzzle game written in <a href=https://www.rust-lang.org>Rust</a>.

The objective is to navigate from the start to the end of an ice-covered playing field, where you slide in the direction
you move until you hit an obstacle.

## How to install

Follow the instructions <a href=https://www.rust-lang.org/tools/install>here</a> to install Rust and Cargo (Rust's package manager).

Clone this repository with `git clone https://github.com/jacobrh91/Glacier-Slide.git`

Compile and run the program with the following:

```
# Move inside the project's directory
cd Glacier-Slide/

# Compile a release build
cargo build --release

# Copy the executable into the current directory
cp target/release/glacier_slide .

# Run the program
./glacier_slide play
```

## How to play

Open the general help menu with `./glacier_slide -h`

### Help Menu

```
Usage: glacier_slide <COMMAND>

Commands:
  play      Play the game in the terminal
  generate  Generate a solvable board and print it as JSON
  serve     Run the HTTP server to generate solvable boards
  help      Print this message or the help of the given subcommand(s)

Options:
  -h, --help     Print help
  -V, --version  Print version
```

### Play/Generate help Menu

```
Play the game in the terminal

Usage: glacier_slide play [OPTIONS] [DIFFICULTY]

Arguments:
  [DIFFICULTY]  Puzzle difficulty [possible values: easy, medium, hard, extreme]

Options:
  -c, --columns <COLUMNS>             Number of columns
  -r, --rows <ROWS>                   Number of rows
  -m, --moves-required <MOVES>        Minimum moves required to win
  -p, --rock-percentage <PERCENTAGE>  Percent of tiles that are rocks
  -v, --full-level-view               Toggle between views
  -d, --debug                         Enable debug mode
  -h, --help                          Print help
```

### Examples

#### Easy Difficulty (Player-centered view)

![Example of an easy level](<imgs/easy.gif>)

#### Medium Difficulty (Full view)

![Example of a medium level](<imgs/full_view.gif>)

### Custom Levels

In addition to selecting a difficulty level, you can pass in additional parameters to customize the level by varying the
  * number of columns
  * number of rows
  * probability of a tile being a rock
  * minimum number of moves required 

(See the "Under the Hood" section for more details)

Note that not all custom level parameters are valid, i.e. it is possible to specify parameters that cannot result in a solvable puzzle.

For example, if you try to create a 3-by-3 puzzle that requires 8 moves to complete, the level generator will never
  finish because no puzzle of that size requires more than 7 moves.

If you try to generate a puzzle with these settings (with debug mode enabled with `-d` or `--debug`), this is what the output looks like.

![Program gives up after 1 million](<imgs/Give up after 1 million.png>)

After generating a million puzzles without success, the level generator gives up.

## Under the Hood

### How levels are generated

Levels are generated by randomly choosing start and end locations and randomly filling the board with rocks (controlled by the `-p` or `--rock-percentage` parameter). All tiles that are not rocks are ice, which do not halt the player's momentum.

After a level has been randomly generated, a solver then determines if the puzzle is solvable and whether the number of steps needed meets the minimum number requested (controlled by the `-m` or `--moves-required` parameter).

### Solving the board with Breadth-First Search (BFS)

Solving a board is a graph traversal, where each vertex is the player's position at rest, and each edge is the next possible move the player could make.

Because we are interested in the shortest possible path from the start to the end, we perform a <a href=https://en.wikipedia.org/wiki/Breadth-first_search>breadth-first search</a>. 

From any stationary position on the board, there are at most two directions in which the player can move. The next move is always orthogonal to the previous move, e.g. if the player just moved up or down, the next move will be to the left or right, and vice versa.

Another pattern to notice is that the optimal solution will never have the player go back in the direction she just came from. For example, after the player just moved left, if moving to the right gets the player closer to the end goal, that would imply that the player should have moved to the right on the previous move.

### Larger levels are possible

You may notice in the command-line arguments parser (`src/parser.rs`) that I have capped the dimensions of the puzzle at 20 tiles and the minimum number of moves to solve at 35. This was somewhat arbitrary, and the program can easily generate much larger levels. But I doubt many people would enjoy a 100 by 100 puzzle that requires 50 moves to solve. 